"""EDL繝輔ぃ繧､繝ｫ逕滓�舌Δ繧ｸ繝･繝ｼ繝ｫ"""

from typing import List, Dict, Any
import os

class EDLGenerator:
    def __init__(self):
        pass

    def generate(self, scenes: List[Dict[str, Any]], output_path: str) -> None:
        """EDL繝輔ぃ繧､繝ｫ繧堤函謌�"""
        # 蜃ｺ蜉帙ョ繧｣繝ｬ繧ｯ繝医Μ縺ｮ菴懈��
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        
        # EDL繝輔ぃ繧､繝ｫ縺ｮ逕滓��
        edl_lines = []
        
        # 繝倥ャ繝繝ｼ
        edl_lines.append("TITLE: Generated by Video Edit Agent")
        edl_lines.append("FCM: NON-DROP FRAME")
        edl_lines.append("")  # 遨ｺ陦�
        
        # 繧ｷ繝ｼ繝ｳ縺ｮ蜃ｦ逅�
        for i, scene in enumerate(scenes, 1):
            try:
                # 繧ｿ繧､繝繧ｳ繝ｼ繝峨�ｮ螟画鋤
                start_tc = self._seconds_to_timecode(scene['start_time'])
                end_tc = self._seconds_to_timecode(scene['end_time'])
                
                # EDL繧ｨ繝ｳ繝医Μ縺ｮ菴懈��
                entry = self._create_edl_entry(
                    i, scene['content_id'], start_tc, end_tc,
                    scene.get('transcript', ''), scene.get('effects', [])
                )
                edl_lines.append(entry)
            except Exception as e:
                print(f"隴ｦ蜻�: 繧ｷ繝ｼ繝ｳ {i} 縺ｮ蜃ｦ逅�荳ｭ縺ｫ繧ｨ繝ｩ繝ｼ縺檎匱逕溘＠縺ｾ縺励◆: {str(e)}")
                continue
        
        # 繝輔ぃ繧､繝ｫ縺ｮ譖ｸ縺崎ｾｼ縺ｿ
        with open(output_path, 'w', encoding='utf-8-sig', newline='\n') as f:
            f.write('\n'.join(edl_lines))

    def _create_edl_entry(self, index: int, clip_name: str,
                         start_tc: str, end_tc: str,
                         transcript: str, effects: List[str]) -> str:
        """EDL繧ｨ繝ｳ繝医Μ繧堤函謌�"""
        # 繧ｨ繝ｳ繝医Μ縺ｮ蝓ｺ譛ｬ讒矩
        entry = [
            f"{index:03d}  {index:03d}     V     C        ",
            f"{start_tc} {end_tc} {start_tc} {end_tc}"
        ]
        
        # 繧ｯ繝ｪ繝�繝怜錐縺ｨ繝医Λ繝ｳ繧ｹ繧ｯ繝ｪ繝励ヨ
        entry.append(f"* FROM CLIP NAME: {clip_name}")
        if transcript:
            entry.append(f"* {transcript}")
        
        # 繧ｨ繝輔ぉ繧ｯ繝域ュ蝣ｱ
        if effects:
            entry.append(f"* EFFECTS: {', '.join(effects)}")
        
        return '\n'.join(entry)

    def _seconds_to_timecode(self, seconds: float) -> str:
        """遘呈焚繧偵ち繧､繝繧ｳ繝ｼ繝牙ｽ｢蠑上↓螟画鋤"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        seconds = int(seconds % 60)
        frames = int((seconds % 1) * 30)  # 30fps繧呈Φ螳�
        
        return f"{hours:02d}:{minutes:02d}:{seconds:02d}:{frames:02d}"
